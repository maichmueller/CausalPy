import numpy as np
import pandas as pd
import logging
import networkx as nx
from networkx.drawing.nx_agraph import graphviz_layout

from typing import List, Union, Dict, Tuple, Iterable
from collections import deque, defaultdict
import matplotlib.pyplot as plt

from src.assignments import BaseAssignment
from src.noise_models import NoiseGenerator


class SCM:
    def __init__(self,
                 assignment_dict: Dict[any, Tuple[Iterable, BaseAssignment, NoiseGenerator]],
                 variable_tex_names: Dict = None,
                 function_key: str = "function",
                 noise_key: str = "noise",
                 scm_name: str = "Structural Causal Model"):

        self.scm_name = scm_name
        # the root variables which are causally happening at first.
        self.roots = []
        self.nr_variables = len(assignment_dict)

        self.var_names = np.array(list(assignment_dict.keys()))
        # supply any variable name, that has not been assigned a different TeX name, itself as TeX name.
        # This prevents missing labels in the plot method.
        if variable_tex_names is not None:
            for name in self.var_names:
                if name not in variable_tex_names:
                    variable_tex_names[name] = name
        # the variable names as they can be used by the plot function to draw the names in TeX mode.
        self.var_names_draw_dict = variable_tex_names

        # the attribute list that any given node in the graph has.
        self.function_key, self.noise_key = function_key, noise_key

        # a backup dictionary of the original assignments of the intervened variables,
        # in order to undo the interventions later.
        self.interventions_attr_backup = dict()
        self.interventions_edge_backup = dict()

        # build the graph:
        # any node will be given the attributes of function and noise to later sample from and also an incoming edge
        # from its causal parent to itself. We will store the causal root nodes separately.
        self.graph = nx.DiGraph()
        for node_name, (parents_list, function, noise_model) in assignment_dict.items():
            self.graph.add_node(node_name, **{self.function_key: function, self.noise_key: noise_model})
            if parents_list:
                for parent in parents_list:
                    self.graph.add_edge(parent, node_name)
            else:
                self.roots.append(node_name)

    def __getitem__(self, item):
        return self.graph[item]

    def __str__(self):
        return self.str()

    def sample(self, n, variables=None, seed=None):
        """
        Sample method to generate data for the given variables. If no list of variables is supplied, the method will
        simply generate data for all variables.
        Setting the seed guarantees reproducibility, however this also currently implies that all randomness is
        generated by a numpy method!

        :param n: int, number of samples
        :param variables: list, the variable names to consider for sampling. If None, all variables will be sampled.
        :param seed: int, the seeding for the numpy generator
        :return: pd.DataFrame, the dataframe containing the samples of all the variables needed for the selection.
        """
        if seed is not None:
            np.random.seed(seed)
        sample = dict()
        for node in self._causal_iterator(variables):
            node_attr = self.graph.nodes[node]
            data = node_attr[self.function_key](
                node_attr[self.noise_key](n),
                *(sample[pred] for pred in self.graph.predecessors(node))
            )
            sample[node] = data
        np.random.seed(None)  # reset random seed
        return pd.DataFrame.from_dict(sample)

    def intervene(self, interventions: Dict[any, Union[Dict, List, Tuple, np.ndarray]]):
        """
        Method to apply the do-calculus on the specified variables.

        One can set any variable to a new assignment function and noise model, thus redefining its parents and their
        dependency structure. Using this method will enable the user to call sample, plot etc. on the SCM just like
        before.
        In order to allow for undoing the intervention(s), the original state of the variables in the network is saved
        as backup and can be undone by calling ``undo_interventions``.

        :param interventions: dict, the variables as keys and their new assignment as values. For the values one can
        choose between a dictionary or a list-like.
        - For dict: the dictionary is assumed to have the keys:
            -- "parents": List of parent variables
            -- "function_key": assignment functor
            -- "noise_key": noise model
        - For list: the order is [Parent list, assignment functor, noise models]
        - For tuple: same as list
        - For ndarray: same as list, but dim == 1 assumed (not checked).
        """
        for var, items in interventions.items():
            if var not in self.graph.nodes:
                logging.warning(f"Variable '{var}' not found in graph. Omitting it.")
                continue

            if isinstance(items, dict):
                if any((key not in items for key in (self.function_key, self.noise_key))):
                    raise ValueError(f"Intervention dictionary provided with the wrong keys.\n"
                                     f"Observed keys were: {list(items.keys())}\n"
                                     f"Expected keys were: [{self.function_key}, {self.noise_key}]")
                attr_dict = items
                try:
                    parent_list = [par for par in self._filter_variable_names(items["parents"])]
                except KeyError:
                    parent_list = []

            elif isinstance(items, (list, tuple, np.ndarray)):
                try:
                    parent_list = [par for par in self._filter_variable_names(items[0])]
                except KeyError:
                    parent_list = []
                attr_dict = {self.function_key: items[1], self.noise_key: items[2]}

            else:
                raise ValueError(f"Intervention items container '{items.__name__}' not supported.")

            self.interventions_attr_backup[var] = self.graph.nodes[var]
            edge_backup = []
            for parent in self.graph.predecessors(var):
                edge_backup.append(parent)
                self.graph.remove_edge(parent, var)
            self.interventions_edge_backup[var] = edge_backup
            for parent in parent_list:
                self.graph.add_edge(parent, var)
            self.graph.add_node(var, **attr_dict)

    def undo_interventions(self, variables: Union[List, Tuple, np.ndarray] = None):
        """
        Method to undo previously done interventions.

        The variables whose interventions should be made undone can be provided in the ``variables`` argument. If no
        list is supplied, all interventions will be undone.
        :param variables: list-like, the variables to be undone.
        """
        if variables is not None:
            present_variables = self._filter_variable_names(variables)
        else:
            present_variables = self.interventions_attr_backup.keys()

        for var in present_variables:
            if var in self.interventions_attr_backup and var in self.interventions_edge_backup:
                self.graph.add_node(var, **self.interventions_attr_backup[var])
                for parent in self.graph.predecessors(var):
                    self.graph.remove_edge(parent, var)
                for parent in self.interventions_edge_backup[var]:
                    self.graph.add_edge(parent, var)
            else:
                logging.warning(f"Variable '{var}' not found in intervention backup. Omitting it.")

    def plot(self, node_size: int = 500, **kwargs):
        pos = graphviz_layout(self.graph, prog='dot')
        plt.title(self.scm_name)
        figsize = kwargs.pop("figsize") if "figsize" in kwargs else (8, 8)
        dpi = kwargs.pop("dpi") if "dpi" in kwargs else 200

        plt.figure(figsize=figsize, dpi=dpi)
        nx.draw(self.graph,
                pos=pos,
                labels=self.var_names_draw_dict,
                with_labels=True,
                node_size=node_size,
                alpha=0.5,
                **kwargs)
        plt.show()

    def str(self):
        lines = [f"Structural Causal Model of {self.nr_variables} variables: " + ", ".join(self.var_names),
                 f"Following variables have been intervened on: {list(self.interventions_attr_backup.keys())}",
                 'Current Assignment Functions are:']
        max_var_space = max([len(var_name) for var_name in self.var_names])
        for node in self.graph.nodes:
            parents_vars = [pred for pred in self.graph.predecessors(node)]
            line = f"{str(node).rjust(max_var_space)} := {self.graph.nodes[node][self.function_key].str(parents_vars)}"
            lines.append(line)
        return "\n".join(lines)

    def _filter_variable_names(self, variables):
        """
        Filter out variable names, that are not currently in the graph. Warn for each variable that wasn't present.
        Returns a generator which iterates over all variables that have been found in the graph.
        :param variables: list, the variables to be filtered
        :return: generator, generates the filtered variables in sequence.
        """
        for variable in variables:
            if variable in self.graph.nodes:
                yield variable
            else:
                logging.warning(f"Variable '{variable}' not found in graph. Omitting it.")

    def _causal_iterator(self, variables=None):
        """
        Provide a causal iterator through the graph starting from the roots going to the variables needed. This iterator
        passes only the ancestors of the variables and thus is helpful in filtering out all the variables that have no
        causal effect on the desired variables.

        :param variables: list, the names of all the variables that are to be considered. Names that cannot be found
        in the naming list of the graph will be ignored (warning raised).
        :return: iterator, a generator object giving back all the ancestors.
        """
        if variables is None:
            return nx.topological_sort(self.graph)
        visited_nodes = set()
        vars_to_sample_priority = defaultdict(int)
        queue = deque([var for var in self._filter_variable_names(variables)])
        while queue:
            nn = queue.popleft()
            if nn not in visited_nodes:
                for parent in self.graph.predecessors(nn):
                    vars_to_sample_priority[parent] = max(
                        vars_to_sample_priority[parent],
                        vars_to_sample_priority[nn] + 1
                    )
                    queue.append(parent)
                visited_nodes.add(nn)
        return (key for (key, value) in sorted(vars_to_sample_priority.items(), key=lambda x: x[1], reverse=True))
